/**
 * Copyright 2012-2015 Niall Gallagher
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.cqengine.query.parser.cqnative.support;

import com.googlecode.cqengine.attribute.Attribute;
import com.googlecode.cqengine.query.Query;
import com.googlecode.cqengine.query.QueryFactory;
import com.googlecode.cqengine.query.parser.antlr4.cqnative.NativeQueryBaseListener;
import com.googlecode.cqengine.query.parser.antlr4.cqnative.NativeQueryParser;
import com.googlecode.cqengine.query.parser.common.ValueParser;
import com.googlecode.cqengine.query.parser.common.QueryParser;
import org.antlr.v4.runtime.tree.TerminalNode;

import java.util.*;

/**
 * @author Niall Gallagher
 */
public class NativeQueryAntlrListener<O> extends NativeQueryBaseListener {

    /*
        NOTE: this class depends on classes auto-generated by the antlr4-maven-plugin.
        Run "mvn clean compile" to generate those classes.
    */

    final QueryParser<O> queryParser;

    // A list of child queries which have not yet been wrapped in a parent query.
    final Deque<Query<O>> pendingQueries = new LinkedList<Query<O>>();

    int numQueriesEncountered = 0;
    int numQueriesParsed = 0;

    public NativeQueryAntlrListener(QueryParser<O> queryParser) {
        this.queryParser = queryParser;
    }

    // ======== Handler methods for each type of query defined in the antlr grammar... ========

    @Override
    public void exitAndQuery(NativeQueryParser.AndQueryContext ctx) {
        int stackSize = pendingQueries.size();
        validateMinimumStackSize(2, stackSize);
        Collection<Query<O>> childQueries = new ArrayList<Query<O>>(stackSize);
        for (int i = 0; i < stackSize; i++) {
            childQueries.add(pendingQueries.pop());
        }
        addPendingQuery(QueryFactory.and(childQueries));
    }

    @Override
    public void exitOrQuery(NativeQueryParser.OrQueryContext ctx) {
        int stackSize = pendingQueries.size();
        validateMinimumStackSize(2, stackSize);
        Collection<Query<O>> childQueries = new ArrayList<Query<O>>(stackSize);
        for (int i = 0; i < stackSize; i++) {
            childQueries.add(pendingQueries.pop());
        }
        addPendingQuery(QueryFactory.or(childQueries));
    }

    @Override
    public void exitNotQuery(NativeQueryParser.NotQueryContext ctx) {
        int stackSize = pendingQueries.size();
        validateStackSize(1, stackSize);
        Query<O> childQuery = pendingQueries.pop();
        addPendingQuery(QueryFactory.not(childQuery));
    }

    @Override
    public void exitEqualQuery(NativeQueryParser.EqualQueryContext ctx) {
        Attribute<O, Object> attribute = getObjectAttribute(getAttributeName(ctx.attributeName()));
        ValueParser<Object> valueParser = queryParser.getValueParser(attribute.getAttributeType());

        NativeQueryParser.QueryParameterContext queryParameter = ctx.queryParameter();
        Object value = valueParser.parse(queryParameter.getText());

        addPendingQuery(QueryFactory.equal(attribute, value));
    }

    @Override
    public void exitLessThanOrEqualToQuery(NativeQueryParser.LessThanOrEqualToQueryContext ctx) {
        Attribute<O, Comparable> attribute = getComparableAttribute(getAttributeName(ctx.attributeName()));
        ValueParser<Comparable> valueParser = queryParser.getValueParser(attribute.getAttributeType());

        NativeQueryParser.QueryParameterContext queryParameter = ctx.queryParameter();
        Comparable value = valueParser.parse(queryParameter.getText());

        addPendingQuery(QueryFactory.lessThanOrEqualTo(attribute, value));
    }

    @Override
    public void exitLessThanQuery(NativeQueryParser.LessThanQueryContext ctx) {
        Attribute<O, Comparable> attribute = getComparableAttribute(getAttributeName(ctx.attributeName()));
        ValueParser<Comparable> valueParser = queryParser.getValueParser(attribute.getAttributeType());

        NativeQueryParser.QueryParameterContext queryParameter = ctx.queryParameter();
        Comparable value = valueParser.parse(queryParameter.getText());

        addPendingQuery(QueryFactory.lessThan(attribute, value));
    }

    @Override
    public void exitGreaterThanOrEqualToQuery(NativeQueryParser.GreaterThanOrEqualToQueryContext ctx) {
        Attribute<O, Comparable> attribute = getComparableAttribute(getAttributeName(ctx.attributeName()));
        ValueParser<Comparable> valueParser = queryParser.getValueParser(attribute.getAttributeType());

        NativeQueryParser.QueryParameterContext queryParameter = ctx.queryParameter();
        Comparable value = valueParser.parse(queryParameter.getText());

        addPendingQuery(QueryFactory.greaterThanOrEqualTo(attribute, value));
    }

    @Override
    public void exitGreaterThanQuery(NativeQueryParser.GreaterThanQueryContext ctx) {
        Attribute<O, Comparable> attribute = getComparableAttribute(getAttributeName(ctx.attributeName()));
        ValueParser<Comparable> valueParser = queryParser.getValueParser(attribute.getAttributeType());

        NativeQueryParser.QueryParameterContext queryParameter = ctx.queryParameter();
        Comparable value = valueParser.parse(queryParameter.getText());

        addPendingQuery(QueryFactory.greaterThan(attribute, value));
    }

    @Override
    public void exitBetweenQuery1(NativeQueryParser.BetweenQuery1Context ctx) {
        Attribute<O, Comparable> attribute = getComparableAttribute(getAttributeName(ctx.attributeName()));
        ValueParser<Comparable> valueParser = queryParser.getValueParser(attribute.getAttributeType());
        ValueParser<Boolean> booleanValueParser = queryParser.getValueParser(Boolean.class);

        List<NativeQueryParser.QueryParameterContext> queryParameters = ctx.queryParameter();
        validateNumberOfParameters(2, queryParameters);

        List<TerminalNode> booleanLiterals = ctx.BooleanLiteral();
        validateNumberOfParameters(2, booleanLiterals);

        Comparable lowerValue = valueParser.parse(queryParameters.get(0).getText());
        boolean lowerInclusive = booleanValueParser.parse(booleanLiterals.get(0).getText());
        Comparable upperValue = valueParser.parse(queryParameters.get(1).getText());
        boolean upperInclusive = booleanValueParser.parse(booleanLiterals.get(1).getText());

        addPendingQuery(QueryFactory.between(attribute, lowerValue, lowerInclusive, upperValue, upperInclusive));
    }

    @Override
    public void exitBetweenQuery2(NativeQueryParser.BetweenQuery2Context ctx) {
        Attribute<O, Comparable> attribute = getComparableAttribute(getAttributeName(ctx.attributeName()));
        ValueParser<Comparable> valueParser = queryParser.getValueParser(attribute.getAttributeType());

        List<NativeQueryParser.QueryParameterContext> queryParameters = ctx.queryParameter();
        validateNumberOfParameters(2, queryParameters);

        Comparable lowerValue = valueParser.parse(queryParameters.get(0).getText());
        Comparable upperValue = valueParser.parse(queryParameters.get(1).getText());

        addPendingQuery(QueryFactory.between(attribute, lowerValue, upperValue));
    }

    @Override
    public void exitInQuery(NativeQueryParser.InQueryContext ctx) {
        Attribute<O, Object> attribute = getObjectAttribute(getAttributeName(ctx.attributeName()));
        ValueParser<Object> valueParser = queryParser.getValueParser(attribute.getAttributeType());

        List<NativeQueryParser.QueryParameterContext> queryParameters = ctx.queryParameter();
        validateMinimumNumberOfParameters(1, queryParameters);

        Collection<Object> values = new ArrayList<Object>(queryParameters.size());
        for (NativeQueryParser.QueryParameterContext queryParameter : queryParameters) {
            Object value = valueParser.parse(queryParameter.getText());
            values.add(value);
        }

        addPendingQuery(QueryFactory.in(attribute, values));
    }

    @Override
    public void exitStartsWithQuery(NativeQueryParser.StartsWithQueryContext ctx) {
        Attribute<O, String> attribute = getStringAttribute(getAttributeName(ctx.attributeName()));
        ValueParser<String> valueParser = queryParser.getValueParser(attribute.getAttributeType());

        NativeQueryParser.StringQueryParameterContext queryParameter = ctx.stringQueryParameter();
        String value = valueParser.parse(queryParameter.getText());

        addPendingQuery(QueryFactory.startsWith(attribute, value));
    }

    @Override
    public void exitEndsWithQuery(NativeQueryParser.EndsWithQueryContext ctx) {
        Attribute<O, String> attribute = getStringAttribute(getAttributeName(ctx.attributeName()));
        ValueParser<String> valueParser = queryParser.getValueParser(attribute.getAttributeType());

        NativeQueryParser.StringQueryParameterContext queryParameter = ctx.stringQueryParameter();
        String value = valueParser.parse(queryParameter.getText());

        addPendingQuery(QueryFactory.endsWith(attribute, value));
    }

    @Override
    public void exitContainsQuery(NativeQueryParser.ContainsQueryContext ctx) {
        Attribute<O, String> attribute = getStringAttribute(getAttributeName(ctx.attributeName()));
        ValueParser<String> valueParser = queryParser.getValueParser(attribute.getAttributeType());

        NativeQueryParser.StringQueryParameterContext queryParameter = ctx.stringQueryParameter();
        String value = valueParser.parse(queryParameter.getText());

        addPendingQuery(QueryFactory.contains(attribute, value));
    }

    @Override
    public void exitIsContainedInQuery(NativeQueryParser.IsContainedInQueryContext ctx) {
        Attribute<O, String> attribute = getStringAttribute(getAttributeName(ctx.attributeName()));
        ValueParser<String> valueParser = queryParser.getValueParser(attribute.getAttributeType());

        NativeQueryParser.StringQueryParameterContext queryParameter = ctx.stringQueryParameter();
        String value = valueParser.parse(queryParameter.getText());

        addPendingQuery(QueryFactory.isContainedIn(attribute, value));
    }

    @Override
    public void exitMatchesRegexQuery(NativeQueryParser.MatchesRegexQueryContext ctx) {
        Attribute<O, String> attribute = getStringAttribute(getAttributeName(ctx.attributeName()));
        ValueParser<String> valueParser = queryParser.getValueParser(attribute.getAttributeType());

        NativeQueryParser.StringQueryParameterContext queryParameter = ctx.stringQueryParameter();
        String value = valueParser.parse(queryParameter.getText());

        addPendingQuery(QueryFactory.matchesRegex(attribute, value));
    }

    @Override
    public void exitHasQuery(NativeQueryParser.HasQueryContext ctx) {
        Attribute<O, Object> attribute = getObjectAttribute(getAttributeName(ctx.attributeName()));
        addPendingQuery(QueryFactory.has(attribute));
    }

    @Override
    public void exitAllQuery(NativeQueryParser.AllQueryContext ctx) {
        String objectTypeParameter = ctx.objectType().getText();
        validateObjectTypeParameter(queryParser.getObjectType(), objectTypeParameter);
        addPendingQuery(QueryFactory.all(queryParser.getObjectType()));
    }

    @Override
    public void exitNoneQuery(NativeQueryParser.NoneQueryContext ctx) {
        String objectTypeParameter = ctx.objectType().getText();
        validateObjectTypeParameter(queryParser.getObjectType(), objectTypeParameter);
        addPendingQuery(QueryFactory.none(queryParser.getObjectType()));
    }

    /** This handler is called for all queries, allows us to validate that no handlers are missing. */
    @Override
    public void exitQuery(NativeQueryParser.QueryContext ctx) {
        numQueriesEncountered++;
        ensureAllQueriesParsed(numQueriesEncountered, numQueriesParsed);
    }

    // ======== Utility methods... ========

    /**
     * Adds the given query to a list of child queries which have not yet been wrapped in a parent query.
     */
    void addPendingQuery(Query<O> parsedQuery) {
        pendingQueries.push(parsedQuery);
        numQueriesParsed++;
    }

    /**
     * Can be called when parsing has finished, to retrieve the parsed query.
     */
    public Query<O> getParsedQuery() {
        validateStackSize(1, pendingQueries.size());
        return pendingQueries.iterator().next();
    }

    Attribute<O, Comparable> getComparableAttribute(String attributeName) {
        Attribute<O, ?> attribute = queryParser.getRegisteredAttribute(attributeName);
        if (!Comparable.class.isAssignableFrom(attribute.getAttributeType())) {
            throw new IllegalStateException("Non-Comparable attribute used in a query which requires a Comparable attribute: " + attribute.getAttributeName());
        }
        @SuppressWarnings("unchecked")
        Attribute<O, Comparable> result = (Attribute<O, Comparable>) attribute;
        return result;
    }

    Attribute<O, String> getStringAttribute(String attributeName) {
        Attribute<O, ?> attribute = queryParser.getRegisteredAttribute(attributeName);
        if (!String.class.isAssignableFrom(attribute.getAttributeType())) {
            throw new IllegalStateException("Non-String attribute used in a query which requires a String attribute: " + attribute.getAttributeName());
        }
        @SuppressWarnings("unchecked")
        Attribute<O, String> result = (Attribute<O, String>) attribute;
        return result;
    }

    Attribute<O, Object> getObjectAttribute(String attributeName) {
        Attribute<O, ?> attribute = queryParser.getRegisteredAttribute(attributeName);
        @SuppressWarnings("unchecked")
        Attribute<O, Object> result = (Attribute<O, Object>) attribute;
        return result;
    }

    String getAttributeName(NativeQueryParser.AttributeNameContext ctx) {
        ValueParser<String> valueParser = queryParser.getValueParser(String.class);
        return valueParser.parse(ctx.getText());
    }

    static void validateObjectTypeParameter(Class<?> expectedType, String actualType) {
        if (!expectedType.getSimpleName().equals(actualType)) {
            throw new IllegalStateException("Unexpected object type parameter, expected: " + expectedType.getSimpleName() + ", found: " + actualType);
        }
    }

    static void validateNumberOfParameters(int expectedNumber, List<?> actualParameters) {
        int size = actualParameters.size();
        if (size != expectedNumber) {
            throw new IllegalStateException("Unexpected number of parameters, expected: " + expectedNumber + ", found: " + size);
        }
    }

    static void validateMinimumNumberOfParameters(int expectedNumber, List<NativeQueryParser.QueryParameterContext> actualParameters) {
        int size = actualParameters.size();
        if (size < expectedNumber) {
            throw new IllegalStateException("Unexpected number of parameters, expected minimum: " + expectedNumber + ", found: " + size);
        }
    }

    static void validateStackSize(int expected, int actual) {
        if (actual != expected) {
            throw new IllegalStateException("Unexpected number of pending queries, expected: " + expected + ", actual: " + actual);
        }
    }

    static void validateMinimumStackSize(int expected, int actual) {
        if (actual < expected) {
            throw new IllegalStateException("Unexpected number of pending queries, expected minimum: " + expected + ", actual: " + actual);
        }
    }

    static void ensureAllQueriesParsed(int numQueriesEncountered, int numQueriesParsed) {
        if (numQueriesEncountered != numQueriesParsed) {
            throw new IllegalStateException("A query declared in the antlr grammar, was not parsed by the listener. If a new query is added in the grammar, a corresponding handler must also be added in the listener.");
        }
    }
}
